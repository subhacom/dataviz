# traubdata.py --- 
# 
# Filename: traubdata.py
# Description: 
# Author: 
# Maintainer: 
# Created: Mon Nov 26 20:44:46 2012 (+0530)
# Version: 
# Last-Updated: Wed Nov 28 15:10:55 2012 (+0530)
#           By: subha
#     Update #: 19
# URL: 
# Keywords: 
# Compatibility: 
# 
# 

# Commentary: 
# 
# Class definition to wrap Traub model simulation data
# 
# 

# Change log:
# 
# 
# 
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street, Fifth
# Floor, Boston, MA 02110-1301, USA.
# 
# 

# Code:

import h5py as h5
import os
print os.getcwd()
from datetime import datetime
import numpy as np
from collections import namedtuple
import random

# This tuple is to be used for storing cell counts for each file
cellcount_tuple = namedtuple('cellcount',
                             ['SupPyrRS',
                              'SupPyrFRB',
                              'SupBasket',
                              'SupAxoaxonic',
                              'SupLTS',
                              'SpinyStellate',
                              'TuftedIB',
                              'TuftedRS',
                              'DeepBasket',
                              'DeepAxoaxonic',
                              'DeepLTS',
                              'NontuftedRS',
                              'TCR',
                              'nRT'],
                             verbose=False)

class TraubData(object):
    """Wrapper for data files generated by traub model simulation

    members:

    fd: hdf5 file handle associated with this object

    cellcounts: cellcount_tuple containing the counts for each cell type

    timestamp: datetime.datetime timestamp of the simulation

    bg_stimulus: array representing timeseries for background stimulus

    probe_stimulus: array representing timeseries for probe stimulus

    simtime: duration of the simulation
    """
    def __init__(self, fname):
        netfilename = os.path.join(os.path.dirname(fname),
                                   os.path.basename(fname).replace('data_', 'network_').replace('.h5', '.h5.new'))
        self.fdata = None
        self.fnet = None
        try:
            self.fdata = h5.File(fname, 'r')
            self.fnet = h5.File(netfilename)
        except IOError as e:
            print e
            return
        self.__get_cellcounts()
        self.__get_timestamp()        
        self.__get_stimuli()
        self.spikes = dict([(cell, np.asarray(self.fdata['/spikes'][cell])) 
                            for cell in self.fdata['/spikes']])
        self.__get_schedinfo()
        self.__get_synapse()
        self.__get_stimulated_cells()
        print 'Loaded', fname

    def __del__(self):
        if self.fdata is not None:
            self.fdata.close()
        if self.fnet is not None:
            self.fnet.close()

    def __get_cellcounts(self):
        if self.fdata is None:
            return
        try:
            cc = dict([(k, int(v)) for k, v in np.asarray(self.fdata['/runconfig/cellcount']) if k in cellcount_tuple._fields])                
            self.cellcounts = cellcount_tuple(**cc)
        except KeyError, e:
            print e           

    def __get_timestamp(self):
        try:
            ts = self.fdata.attrs['timestamp']
            self.timestamp = datetime.strptime(ts, '%Y-%m-%d %H:%M:%S')
        except (ValueError, KeyError):
            # Older files do not have the time stamp attribute
            # But all data files are named according to the scheme:
            # data_YYYYmmdd_HHMMSS_PID.h5
            tokens = os.path.basename(self.fdata.filename).split('_')
            ts = tokens[1] + tokens[2]
            self.timestamp = datetime.strptime(ts, '%Y%m%d%H%M%S')

    def __get_stimuli(self):
        try:
            self.bg_stimulus = np.asarray(self.fdata['/stimulus/stim_bg'])
            self.probe_stimulus = np.asarray(self.fdata['/stimulus/stim_probe'])
        except KeyError as e:
            print e
        
    def __get_schedinfo(self):
        schedinfo = dict(self.fdata['/runconfig/scheduling'])
        self.simtime = float(schedinfo['simtime'])
        self.simdt = float(schedinfo['simdt'])
        self.plotdt = float(schedinfo['plotdt'])

    def __get_synapse(self):
        try:
            self.synapse = np.asarray(self.fnet['/network/synapse'])
        except KeyError as e:
            print self.fdata.filename, 'encountered error'
            print e
            raise(e)
            
    def get_notes(self):
        return self.fdata.attrs['notes']
        
    def presynaptic(self, cellname):
        indices = np.char.startswith(self.synapse['dest'], cellname+'/')
        return list(set([row[0] for  \
                row in np.char.split(self.synapse['source'][indices], '/')]))

    def postsynaptic(self, cellname):
        indices = np.char.startswith(self.synapse['source'], cellname+'/')
        return list(set([row[0] for  \
                row in np.char.split(self.synapse['dest'][indices], '/')]))

    def __get_stimulated_cells(self):
        """Create the attributes `bg_cells` and `probe_cells` - lists
        of cells that received background stimulus and probe stimulus
        resepctively.
        
        """
        if hasattr(self, 'bg_cells'):
            return
        stiminfo = np.asarray(self.fnet['/stimulus/connection'])
        self.bg_cells = [ token[-2] \
                          for token in np.char.split(stiminfo[np.char.endswith(stiminfo['f0'], 'stim_bg')]['f1'], '/')]
        self.probe_cells = [token[-2] \
                            for token in np.char.split(stiminfo[np.char.endswith(stiminfo['f0'], 'stim_probe')]['f1'], '/')]

    def get_bg_stimulated_cells(self, celltype):
        """Get the cells which get input from a TCR cell receiving
        background stimulus"""
        post_cells = []
        for cell in self.bg_cells:
            post_cells += self.postsynaptic(cell)
        return [cell for cell in set(post_cells) if cell.startswith(celltype)]
        
    def get_probe_stimulated_cells(self, celltype):
        """Get the cells which get input from a TCR cell receiving
        probe stimulus"""
        post_cells = []
        for cell in self.probe_cells:
            post_cells += self.postsynaptic(cell)
        return [cell for cell in set(post_cells) if cell.startswith(celltype)]

    def bg_stimulus_spike_correlations(self, celltype, window):
        cells = self.get_bg_stimulated_cells(celltype)
        raise NotImplementedError('TODO: finish')

    def get_bgstim_times(self):
        ts = np.linspace(0, self.simtime, len(self.bg_stimulus))
        indices = np.nonzero(np.diff(self.bg_stimulus))
        return ts[indices]



# 
# traubdata.py ends here
