# traubdata.py --- 
# 
# Filename: traubdata.py
# Description: 
# Author: 
# Maintainer: 
# Created: Mon Nov 26 20:44:46 2012 (+0530)
# Version: 
# Last-Updated: Sat Dec 15 15:37:45 2012 (+0530)
#           By: subha
#     Update #: 245
# URL: 
# Keywords: 
# Compatibility: 
# 
# 

# Commentary: 
# 
# Class definition to wrap Traub model simulation data
# 
# 

# Change log:
# 
# 
# 
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street, Fifth
# Floor, Boston, MA 02110-1301, USA.
# 
# 

# Code:

import h5py as h5
import os
print os.getcwd()
from datetime import datetime
import numpy as np
from collections import namedtuple
import random

# This tuple is to be used for storing cell counts for each file
cellcount_tuple = namedtuple('cellcount',
                             ['SupPyrRS',
                              'SupPyrFRB',
                              'SupBasket',
                              'SupAxoaxonic',
                              'SupLTS',
                              'SpinyStellate',
                              'TuftedIB',
                              'TuftedRS',
                              'DeepBasket',
                              'DeepAxoaxonic',
                              'DeepLTS',
                              'NontuftedRS',
                              'TCR',
                              'nRT'],
                             verbose=False)


class TraubData(object):
    """Wrapper for data files generated by traub model simulation

    members:

    fd: hdf5 file handle associated with this object

    cellcounts: cellcount_tuple containing the counts for each cell type

    timestamp: datetime.datetime timestamp of the simulation

    bg_stimulus: array representing timeseries for background stimulus

    probe_stimulus: array representing timeseries for probe stimulus

    simtime: duration of the simulation
    """
    def __init__(self, fname):
        netfilename = os.path.join(os.path.dirname(fname),
                                   os.path.basename(fname).replace('data_', 'network_').replace('.h5', '.h5.new'))
        self.fdata = None
        self.fnet = None
        try:
            self.fdata = h5.File(fname, 'r')
            self.fnet = h5.File(netfilename)
        except IOError as e:
            print e
            return
        self.__get_cellcounts()
        self.__get_timestamp()        
        self.__get_stimuli()
        self.spikes = dict([(cell, np.asarray(self.fdata['/spikes'][cell])) 
                            for cell in self.fdata['/spikes']])
        self.__get_schedinfo()
        self.__get_synapse()
        self.__get_stimulated_cells()
        print 'Loaded', fname

    def __del__(self):
        if self.fdata is not None:
            self.fdata.close()
        if self.fnet is not None:
            self.fnet.close()

    def __get_cellcounts(self):
        if self.fdata is None:
            return
        try:
            cc = dict([(k, int(v)) for k, v in np.asarray(self.fdata['/runconfig/cellcount']) if k in cellcount_tuple._fields])                
            self.cellcounts = cellcount_tuple(**cc)
        except KeyError, e:
            print e           

    def __get_timestamp(self):
        try:
            ts = self.fdata.attrs['timestamp']
            self.timestamp = datetime.strptime(ts, '%Y-%m-%d %H:%M:%S')
        except (ValueError, KeyError):
            # Older files do not have the time stamp attribute
            # But all data files are named according to the scheme:
            # data_YYYYmmdd_HHMMSS_PID.h5
            tokens = os.path.basename(self.fdata.filename).split('_')
            ts = tokens[1] + tokens[2]
            self.timestamp = datetime.strptime(ts, '%Y%m%d%H%M%S')

    def __get_stimuli(self):
        try:
            self.bg_stimulus = np.asarray(self.fdata['/stimulus/stim_bg'])
            self.probe_stimulus = np.asarray(self.fdata['/stimulus/stim_probe'])
        except KeyError as e:
            print e
        
    def __get_schedinfo(self):
        schedinfo = dict(self.fdata['/runconfig/scheduling'])
        self.simtime = float(schedinfo['simtime'])
        self.simdt = float(schedinfo['simdt'])
        self.plotdt = float(schedinfo['plotdt'])

    def __get_synapse(self):
        try:
            self.synapse = np.asarray(self.fnet['/network/synapse'])
        except KeyError as e:
            print self.fdata.filename, 'encountered error'
            print e
            raise(e)
            
    def get_notes(self):
        return self.fdata.attrs['notes']
        
    def presynaptic(self, cellname):
        indices = np.char.startswith(self.synapse['dest'], cellname+'/')
        return list(set([row[0] for  \
                row in np.char.split(self.synapse['source'][indices], '/')]))

    def postsynaptic(self, cellname):
        indices = np.char.startswith(self.synapse['source'], cellname+'/')
        return list(set([row[0] for  \
                row in np.char.split(self.synapse['dest'][indices], '/')]))

    def __get_stimulated_cells(self):
        """Create the attributes `bg_cells` and `probe_cells` - lists
        of cells that received background stimulus and probe stimulus
        resepctively.
        
        """
        if hasattr(self, 'bg_cells'):
            return
        stiminfo = np.asarray(self.fnet['/stimulus/connection'])
        self.bg_cells = [ token[-2] \
                          for token in np.char.split(stiminfo[np.char.endswith(stiminfo['f0'], 'stim_bg')]['f1'], '/')]
        self.probe_cells = [token[-2] \
                            for token in np.char.split(stiminfo[np.char.endswith(stiminfo['f0'], 'stim_probe')]['f1'], '/')]

    def get_bg_stimulated_cells(self, celltype):
        """Get the cells which get input from a TCR cell receiving
        background stimulus"""
        post_cells = []
        for cell in self.bg_cells:
            post_cells += self.postsynaptic(cell)
        return [cell for cell in set(post_cells) if cell.startswith(celltype)]
        
    def get_probe_stimulated_cells(self, celltype):
        """Get the cells which get input from a TCR cell receiving
        probe stimulus"""
        post_cells = []
        for cell in self.probe_cells:
            post_cells += self.postsynaptic(cell)
        return [cell for cell in set(post_cells) if cell.startswith(celltype)]

    def bg_stimulus_spike_correlations(self, celltype, window):
        cells = self.get_bg_stimulated_cells(celltype)
        raise NotImplementedError('TODO: finish')

    def get_bgstim_times(self):
        ts = np.linspace(0, self.simtime, len(self.bg_stimulus))
        indices = np.nonzero(np.diff(self.bg_stimulus))
        return ts[indices]

    def get_spiking_cell_hist(self, celltype, timerange=(0,1e9), binsize=5e-3):
        """Get the number of cells spiking in each time bin of width
        `binsize`.

        celltype: cell population to search

        timerange: 2-tuple (starttime, endtime) where only the region
        within this period is considered.

        binsize: the time interval within which spikes from two cells
        must fall to be called synchronous.

        Return (cellcount-histogram, bins).

        numpy.histogram function is used to compute the number of
        cells spiking in a bin. So the results depend on where you
        start the time. Ideally one should do a sliding to get the
        maximums.
        """
        tstart = 0
        if timerange[0] > tstart:
            tstart = timerange[0]
        tend = data.simtime
        if timerange[1] < tend:
            tend  = timerange[1]
        assert(tend > tstart)
        cells = np.asarray(self.spikes.keys())
        cells = cells[np.char.startswith(celltype)]
        bins = np.arange(tstart, tend, binsize)
        # Get the histograms of spikes for each cell
        histlist = [np.histogram(self.spikes[cell], bins)[0] for cell in cells]
        # If there was nonzero spike in the bin, the cell counts
        # towards firing cell in that bin
        histlist = [np.where(hist > 0, 1.0, 0.0) for hist in histlist]
        return (np.sum(histlist, axis=0), bins)

    def get_popspike_times(self, celltype, cutoff=0.5, timerange=(0,1e9), binsize=5e-3):
        """Return the centre of the bins in which more than `cutoff`
        fraction of cells of `celltype` fired.

        Get loose measure of popspike times for celltype.

        This sums up the number of cells firing in each bin and if
        this is more than `cutoff` fraction of the population, counts
        it as a population spike.
        """
        cellcounts = self.get_spiking_cell_hist(celltype, timerange, binsize)[0]
        fracs = cellcounts * 1.0 / self.cellcounts._asdict[celltype]
        indices = np.nonzero(fracs > cutoff)[0]
        return (indices+0.5) * binsize

    def get_burst_arrays(self, celltype, timerange=(0, 1e9), mincount=3, maxisi=15e-3):
        """Get bursts of spikes where two spikes within maxisi are
        considered part of the same burst.

        celltype: string or list of strings.  If it is a string, it is
        taken as celltype and data for all cells starting with this
        string is returned.  If a list of string, this is taken as
        name of cells and data for cells with these names is returned.
        
        Returns a dict of cells to bursts. bursts is a list of arrays
        containing spiketimes for members of the burst.

        """
        tstart = 0
        if timerange[0] > tstart:
            tstart = timerange[0]
        tend = self.simtime
        if timerange[1] < tend:
            tend = timerange[1]
        assert(tend > tstart)
        if isinstance(celltype, str):
            cell_spiketrain = [(cell, spiketrain[(spiketrain >= tstart) & (spiketrain < tend)])
                               for cell, spiketrain in self.spikes.items() 
                               if cell.startswith(celltype)]
        else:
            cell_spiketrain = []
            for cell in celltype:
                spiketrain = self.spikes[cell]
                spiketrain = spiketrain[(spiketrain >= tstart) & (spiketrain < tend)]
                cell_spiketrain.append((cell, spiketrain))
        burst_dict = dict([(cell, [spiketimes 
                                   for spiketimes in np.array_split(sp, np.where(np.diff(sp) > maxisi)[0]+1) 
                                   if len(spiketimes) >= mincount])
                           for cell, sp in cell_spiketrain])        
        return burst_dict

    def get_bursts(self, celltype, timerange=(0, 1e9), mincount=3, maxisi=15e-3):
        """Get a dictionary of cells to bursts in its spike train.

        The bursts are presented as a Nx2 array where each row is
        (start_index, length) and N is the total number of detected
        bursts.

        """
        tstart = 0
        if timerange[0] > tstart:
            tstart = timerange[0]
        tend = self.simtime
        if tend > timerange[1]:
            tend = timerange[1]
        assert(tend > tstart)
        if isinstance(celltype, str):
            cells = [cell for cell in self.spikes.keys() if cell.startswith(celltype)]
        else:
            cells = celltype
        burst_dict = {}
        for cell in cells:
            spikes = self.spikes[cell]
            spikes = spikes[(spikes >= tstart) & (spikes < tend)].copy()
            ISI = np.diff(spikes)
            ISI_limit = np.diff(np.where(ISI < maxisi, 1, 0))
            begin_int = np.nonzero(ISI_limit == 1)[0] + 1
            if ISI[0] < maxisi:
                begin_int = np.r_[0, begin_int]
            end_int = np.nonzero(ISI_limit == -1)[0] + 1
            if len(end_int) < len(begin_int):
                end_int = np.r_[end_int, len(ISI)-1]
            burst_dict[cell] = np.asarray([(start, end - start + 1) \
                                               for start, end in zip(begin_int, end_int) \
                                               if end - start + 1 >= mincount-1], dtype=int)
        return burst_dict        

    def get_bursting_cells_hist(self, celltype, timerange=(0,1e9), binsize=100e-3, mincount=3, maxisi=15e-3):
        """Get histogram containing number of cells bursting in each
        bin of `binsize` width"""
        tstart = 0
        if timerange[0] > tstart:
            tstart = timerange[0]
        tend = self.simtime
        if timerange[1] < tend:
            tend = timerange[1]
        bins = np.arange(tstart, tend, binsize)
        burst_dict = self.get_burst_arrays(celltype, timerange=timerange, mincount=mincount, maxisi=maxisi)
        hists = [np.histogram([np.mean(burst) for burst in burst_train], bins)[0] for burst_train in burst_dict.values()]
        hists = [np.where(h > 0, 1.0, 0.0) for h in hists]
        return (np.sum(hists, axis=0), bins)

    def pop_ibi(self, cells):
        """Get the interburst interval for `cells` population in data.

        We get the interburst intervals of `cells`.

        data: TraubData instance

        cells: str or list of str if a single string is specified, it is
        taken as the celltype and all cellnames starting with this string
        are included.

        If a list of strings, the entries are taken as exact cellnames.

        """
        burst_dict = self.get_burst_arrays(cells)
        
                
from matplotlib import pyplot as plt

if __name__ == '__main__':
    # for testing
    data = TraubData('/data/subha/rsync_ghevar_cortical_data_clone/2012_11_07/data_20121107_100729_29479.h5')
    b = data.get_bursts('SpinyStellate')
    index = 0
    for cell, bursts in b.items():
        index += 1        
        print cell, len(bursts)
        if len(bursts) == 0:
            continue
        print bursts
        spikes = data.spikes[cell]
        print '==='
        for t in  spikes:
            print t
        print '==='
        plt.plot(spikes, np.ones(len(spikes))*index, 'b+')
        plt.plot(spikes[bursts[:,0]], np.ones(len(bursts))*index, 'gx')
        plt.plot(spikes[np.sum(bursts, axis=1)-1], np.ones(len(bursts))*index, 'rx')
        break
    plt.show()

# 
# traubdata.py ends here
