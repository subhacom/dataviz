# animate3d.py --- 
# 
# Filename: animate3d.py
# Description: 
# Author: Subhasis Ray
# Maintainer: 
# Created: Thu Aug 11 09:49:49 2011 (+0530)
# Version: 
# Last-Updated: Fri Aug 12 14:05:12 2011 (+0530)
#           By: Subhasis Ray
#     Update #: 280
# URL: 
# Keywords: 
# Compatibility: 
# 
# 

# Commentary: 
# 
# Attempt to use vtk for 3D visualization of data from Traub model simulation 
# 
# 

# Change log:
# 
# 
# 

# Code:

from collections import defaultdict
import numpy

import csv
import h5py
import vtk
from vtk.util import numpy_support as vtknp

class TraubDataHandler(object):
    """Reader for data generated by Traub model."""
    def __init__(self):
        self.class_cell = defaultdict(list)
        self.class_pos = {}
        self.cellname = [] # List of cells
        self.pos = None    # List of positions - must have same order as cellname
        self.vm = None # List of vms - must have the same order as cellname
        self.datafile = None
        self.cellclass = []
        self.simtime = None
        self.plotdt = None

    def read_posdata(self, filename):
        """Read position data from file"""
        with open(filename, 'r') as filehandle:
            reader = csv.DictReader(filehandle, fieldnames=['cellclass', 'depth', 'start', 'end', 'dia', 'layer', 'isInTraub'], delimiter='\t', quotechar='"')
                                                          
            reader.next()
            for row in reader:
                self.class_pos[row['cellclass']] = row
                self.cellclass.append(row['cellclass'])

    def read_celldata(self,filename):
        """Read the Vm data from the hdf5 file"""
        self.datafile = h5py.File(filename, 'r')            
        self.vm_node = self.datafile['/Vm']
        for cellname in self.vm_node.keys():
            tmp = cellname.partition('_')
            cellclass = tmp[0]
            self.class_cell[cellclass].append(cellname)
        for cellclass in self.cellclass:
            self.cellname.extend(self.class_cell[cellclass])
        self.vm = numpy.array([self.vm_node[cellname] for cellname in self.cellname])

    def generate_cellpos(self):
        """Create random positions based on depth and diameter data
        for the cells"""
        for cellclass in self.cellclass:
            start = float(self.class_pos[cellclass]['start'])
            end = float(self.class_pos[cellclass]['end'])
            rad = float(self.class_pos[cellclass]['dia'])/2.0
            size = len(self.class_cell[cellclass])
            zpos = numpy.random.uniform(low=start, high=end, size=size)
            rpos = numpy.sqrt(numpy.random.uniform(low=start, high=end, size=size)/numpy.pi)
            theta = numpy.random.uniform(low=start, high=end, size=size)
            xpos = rpos * numpy.cos(theta)
            ypos = rpos * numpy.sin(theta)
            pos = numpy.column_stack((xpos, ypos, zpos))
            if pos.size == 0:
                continue
            try:
                self.pos = numpy.concatenate((self.pos, pos), 1)
            except ValueError:
                self.pos = pos
        self.pos = numpy.array(self.pos, copy=True, order='C')

    def update_times(self):
        try:
            self.simtime = self.datafile.attrs['simtime']
            self.plotdt = self.datafile.attrs['plotdt']
        except KeyError, e:
            print 'simtime or plotdt attribute absent'
            self.simtime = None
            self.plotdt = None
        if self.simtime is None or self.plotdt is None:
            try:
                firstcell = self.cellname[0]
                self.simtime = float(len(self.vm_node[firstcell]))
                self.plotdt = 1.0
            except IndexError, e:
                print 'There are no Vm arrays in the data file.'
                raise e
        
    def get_vm(self, step):
        """Get the Vm for all cells at step ordered in the same
        sequence as cellname."""
        return numpy.array(self.vm[:][step], copy=True, order='C')

    def get_range(self, cellclass):
        start = 0
        end = 0
        for classname, celllist in self.class_cell.items():
            if classname == cellclass:
                end = start + len(celllist)
                break
            else:
                start = start + len(celllist)
        return (start, end)
            
    def __del__(self):
        self.datafile.close()
    
class TraubDataVis(object):
    """Visualizer for Traub model data"""
    def __init__(self):
        self.datafile = None
        self.posfile = None
        self.datahandler = TraubDataHandler()        

    def load_data(self, posfilename, datafilename):
        self.datahandler.read_posdata(posfilename)
        self.datahandler.read_celldata(datafilename)
        self.datahandler.generate_cellpos()
        self.datahandler.update_times()

    def setup_visualization(self):
        self.positionSource = {}
        self.sphereSource = {}
        self.mapper = {}
        self.glyph = {}
        self.actor = {}
        self.renderer = vtk.vtkRenderer()
        self.renwin = vtk.vtkRenderWindow()
        self.renwin.AddRenderer(self.renderer)
        self.interactor = vtk.vtkRenderWindowInteractor()
        self.interactor.SetRenderWindow(self.renwin)
        for classname in self.datahandler.cellclass:
            cellrange = self.datahandler.get_range(classname)
            if cellrange[0] == cellrange[1]:
                continue
            # print cellrange, 
            pos = self.datahandler.pos[cellrange[0]: cellrange[1]]
            # print pos, pos.size
            pos_array = vtknp.numpy_to_vtk(pos, deep=True)
            points = vtk.vtkPoints()
            points.SetData(pos_array)
            polydata = vtk.vtkPolyData()
            polydata.SetPoints(points)
            data = self.datahandler.get_vm(0)
            polydata.GetPointData().SetScalars(vtknp.numpy_to_vtk(data))
            self.positionSource[classname] = polydata 
            sphere = vtk.vtkSphereSource()
            sphere.SetRadius(1)
            sphere.SetThetaResolution(20)
            sphere.SetPhiResolution(20)
            self.sphereSource[classname] = sphere
            glyph = vtk.vtkGlyph3D()
            glyph.SetSource(sphere.GetOutput())
            glyph.SetInput(polydata)
            self.glyph[classname] = glyph
            mapper = vtk.vtkPolyDataMapper()
            mapper.SetInput(glyph.GetOutput())
            self.mapper[classname] = mapper
            actor = vtk.vtkActor()
            actor.SetMapper(mapper)
            self.actor[classname] = actor
            self.renderer.AddActor(actor)
        print 'End setup_visualization'

    def display(self):
        self.interactor.Initialize()
        self.interactor.Start()

if __name__ == '__main__':
    posfile = '/home/subha/src/sim/cortical/dataviz/cellpos.csv'
    datafile = '/home/subha/src/sim/cortical/py/data/data_20101201_102647_8854.h5'
    vis = TraubDataVis()
    vis.load_data(posfile, datafile)
    vis.setup_visualization()
    vis.display()
        

# 
# animate3d.py ends here
